import json
import sys
from pathlib import Path

import pytest
from jinja2 import Environment, FileSystemLoader

from hab import utils

# Create a test for each dir in reference_scripts. We pass the name of the folder
# so test selection matches the name of the folder instead of something abstract
# like [reference5].
reference_scripts = Path(__file__).parent / "reference_scripts"
reference_names = [x.name for x in reference_scripts.iterdir()]


@pytest.mark.parametrize("reference_name", reference_names)
def test_scripts(resolver, tmpdir, monkeypatch, config_root, reference_name):
    """Checks all of the scripts HabBase.write_script generates for a specified
    set of arguments.

    This is a parametrized test, and each folder inside the tests/reference_scripts
    directory adds a test. Each directory needs a spec.json file similar to this::

        {
            "description": "[shell and platform]: Tests `hab [command] [uri]`",
            "ext": ".sh",
            "launch": null,
            "exiting": false,
            "args": null,
            "create_launch": false,
            "platform": "linux",
            "uri": "not_set/child"
        }

    A reference directory needs to have at least one script file generated by hab,
    and all files are expected to be created by write_script.

    To add a new test, create the new directory and add the desired spec file.
    Run the test(it will fail) and in the pytest temp directory you can find the
    script files that hab generated for your spec. Copy them into your reference
    directory. You will then need to replace the hard coded file paths with jinja2
    templates to ensure your test will pass on the next run of pytest, as well
    as when the git checkout is in a different location. There are a few required
    replacements needed:

    1. Replace the path to the test's tempdir with `{{ tmpdir }}`. If joining
        paths to tmpdir, do it as part of the format to ensure correct slash
        direction. `{{ tmpdir / "filename.txt" }}`
    2. Replace the path to your checkout's tests directory with `{{ config_root }}`
        making sure to convert back slashes to forward slashes
    3. Replace the HAB_FREEZE value with `{{ freeze }}`.
    """
    reference = reference_scripts / reference_name
    spec = json.load((reference / "spec.json").open())

    if "description" in spec:
        print(f"Testing: {spec['description']}")

    # Script formatting is subtly different on different platforms, ensure we
    # are testing the requested platform, not the current one.
    platform = spec["platform"]
    assert platform in ("linux", "mac", "win32")
    monkeypatch.setattr(sys, 'platform', platform)

    cfg = resolver.resolve(spec["uri"])
    reference = config_root / "reference_scripts" / reference_name
    ext = spec["ext"]

    cfg.write_script(
        str(tmpdir),
        ext=ext,
        launch=spec["launch"],
        exit=spec["exiting"],
        args=spec["args"],
        create_launch=spec["create_launch"],
    )
    # Test specific values to update the reference templates with for comparison
    replacements = {
        "freeze": utils.encode_freeze(cfg.freeze()),
        # Replace the path to the test's tempdir with `{{ tmpdir }}`
        "tmpdir": tmpdir,
        # Replace the path to your checkout's tests directory with
        # `{{ config_root }}` making sure to convert back slashes to forward slashes
        "config_root": utils.path_forward_slash(config_root),
    }

    def check_file(item):
        rel_path = item.relative_to(reference)
        generated = tmpdir / rel_path

        # Fill in the dynamic variables in the reference file to ensure the test
        # passes for the current git checkout location and pytest's temp dir.
        # Using Jinja for this because other python str formatting methods require
        # too much manipulation of the reference files.
        environment = Environment(
            loader=FileSystemLoader(item.parent), trim_blocks=True, lstrip_blocks=True
        )
        template = environment.get_template(item.name)
        # Note: jinja2' seems to be inconsistent with its trailing newlines depending
        # on the template and its if statements, so force a single trailing newline
        ref_text = template.render(**replacements).rstrip() + "\n"

        try:
            assert generated.exists()
            assert (
                ref_text == generated.open().read()
            ), "Reference does not match generated"
        except AssertionError:
            print("")
            print(f"Reference: {item}")
            print(f"Generated: {generated}")
            raise

    def walk_dir(current):
        found_script = False
        for item in current.iterdir():
            if item.name == 'spec.json':
                continue
            elif item.is_file():
                check_file(item)
                # At least one file was found beyond spec.json so test is valid
                found_script = True
            else:
                walk_dir(item)
        assert (
            found_script
        ), f"Reference dir needs to contain at least one script. {reference}"

    walk_dir(reference)
